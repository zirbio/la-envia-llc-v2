"""
Base class for One-Off Trading Strategies

One-off strategies are invoked on demand (not automated like ORB).
Each strategy implements the abstract base class and provides
its own signal generation logic.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import List, Optional

import pandas as pd
from loguru import logger

from config.settings import settings
from data.market_data import market_data
from data.indicators import IndicatorCalculator


class SignalDirection(Enum):
    """Direction of the trading signal"""
    LONG = "LONG"
    SHORT = "SHORT"


@dataclass
class OneOffSignal:
    """Signal generated by a one-off strategy"""
    symbol: str
    strategy_name: str
    direction: SignalDirection
    entry_price: float
    stop_loss: float
    take_profit_1: float
    take_profit_2: Optional[float]
    position_size: int
    risk_amount: float
    score: float
    reasoning: str
    timestamp: datetime

    # Technical context (optional)
    vwap: Optional[float] = None
    rsi: Optional[float] = None
    atr: Optional[float] = None
    relative_volume: Optional[float] = None

    def __str__(self) -> str:
        emoji = "ğŸŸ¢" if self.direction == SignalDirection.LONG else "ğŸ”´"
        tp2_str = f" â†’ TP2: ${self.take_profit_2:.2f}" if self.take_profit_2 else ""
        return (
            f"{emoji} {self.direction.value} {self.symbol} [{self.strategy_name}]\n"
            f"Entry: ${self.entry_price:.2f}\n"
            f"Stop: ${self.stop_loss:.2f}\n"
            f"TP1: ${self.take_profit_1:.2f}{tp2_str}\n"
            f"Size: {self.position_size} shares\n"
            f"Risk: ${self.risk_amount:.2f}\n"
            f"Score: {self.score:.0f}/100\n"
            f"Reason: {self.reasoning}"
        )

    def to_telegram_message(self) -> str:
        """Format signal for Telegram notification"""
        emoji = "ğŸŸ¢" if self.direction == SignalDirection.LONG else "ğŸ”´"
        tp2_str = f"\nğŸ¯ TP2: ${self.take_profit_2:.2f}" if self.take_profit_2 else ""

        return (
            f"{emoji} <b>{self.direction.value} {self.symbol}</b>\n"
            f"ğŸ“Š Strategy: {self.strategy_name}\n"
            f"ğŸ’° Entry: ${self.entry_price:.2f}\n"
            f"ğŸ›‘ Stop: ${self.stop_loss:.2f}\n"
            f"ğŸ¯ TP1: ${self.take_profit_1:.2f}{tp2_str}\n"
            f"ğŸ“ˆ Size: {self.position_size} shares\n"
            f"âš ï¸ Risk: ${self.risk_amount:.2f}\n"
            f"â­ Score: {self.score:.0f}/100\n\n"
            f"<i>{self.reasoning}</i>"
        )


class OneOffStrategy(ABC):
    """
    Abstract base class for all one-off strategies.

    One-off strategies:
    - Are invoked on demand (not scheduled)
    - Each has its own entry/exit conditions
    - Use the same market data and indicators infrastructure
    - Generate OneOffSignal objects for execution
    """

    def __init__(self):
        self.trading_config = settings.trading
        self.signals_generated: List[OneOffSignal] = []

    @property
    @abstractmethod
    def name(self) -> str:
        """Unique identifier for the strategy (e.g., 'vwap_reversion')"""
        pass

    @property
    @abstractmethod
    def display_name(self) -> str:
        """Human-readable name (e.g., 'VWAP Mean Reversion')"""
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """Brief description of what the strategy does"""
        pass

    @abstractmethod
    async def scan_opportunities(
        self,
        symbols: List[str]
    ) -> List[OneOffSignal]:
        """
        Scan a list of symbols for trading opportunities.

        Args:
            symbols: List of stock symbols to scan

        Returns:
            List of valid signals found
        """
        pass

    @abstractmethod
    def calculate_score(self, **kwargs) -> float:
        """
        Calculate signal quality score (0-100).

        Higher scores indicate stronger setups.
        Each strategy defines its own scoring criteria.

        Returns:
            Score from 0 to 100
        """
        pass

    def get_market_data(self, symbol: str, limit: int = 50) -> pd.DataFrame:
        """
        Get market data with all indicators calculated.

        Args:
            symbol: Stock symbol
            limit: Number of bars to retrieve

        Returns:
            DataFrame with OHLCV and technical indicators
        """
        bars = market_data.get_bars(symbol, limit=limit)
        if bars.empty:
            return bars

        calculator = IndicatorCalculator(bars)
        calculator.add_all_indicators()
        return calculator.df

    def get_latest_indicators(self, symbol: str) -> dict:
        """
        Get the latest indicator values for a symbol.

        Args:
            symbol: Stock symbol

        Returns:
            Dict with latest indicator values
        """
        bars = market_data.get_bars(symbol, limit=50)
        if bars.empty:
            return {}

        calculator = IndicatorCalculator(bars)
        calculator.add_all_indicators()
        return calculator.get_latest_indicators()

    def calculate_position_size(
        self,
        entry_price: float,
        stop_loss: float,
        risk_pct: Optional[float] = None
    ) -> tuple[int, float]:
        """
        Calculate position size based on risk.

        Args:
            entry_price: Entry price
            stop_loss: Stop loss price
            risk_pct: Optional custom risk percentage (default from config)

        Returns:
            Tuple of (position_size, risk_amount)
        """
        risk_per_share = abs(entry_price - stop_loss)

        if risk_per_share == 0:
            return 0, 0.0

        if risk_pct is None:
            risk_pct = self.trading_config.risk_per_trade

        max_risk = self.trading_config.max_capital * risk_pct
        position_size = int(max_risk / risk_per_share)

        # Ensure we don't exceed max capital
        max_shares = int(self.trading_config.max_capital / entry_price)
        position_size = min(position_size, max_shares)

        # Minimum position size
        position_size = max(position_size, 1)

        actual_risk = position_size * risk_per_share

        logger.debug(
            f"Position sizing: risk_pct={risk_pct:.2%}, "
            f"position={position_size} shares, risk=${actual_risk:.2f}"
        )

        return position_size, actual_risk

    def get_documentation_path(self) -> str:
        """Get the path to this strategy's documentation file"""
        return f"docs/oneoff/{self.name.upper()}.md"

    def reset(self) -> None:
        """Reset strategy state (clear generated signals)"""
        self.signals_generated.clear()
        logger.info(f"Strategy {self.name} reset")
